package exception

import (
	"encoding/json"
	"fmt"
	"runtime"
	"strings"
)

type Exception struct {
	message        string
	stackTrace     []string
	innerException *Exception
}

func (e *Exception) MarshalJSON() ([]byte, error) {
	values := map[string]interface{}{}
	values["message"] = e.message
	values["stack_trace"] = e.StackTrace()

	return json.Marshal(values)
}

func (e *Exception) Message() string {
	if e.innerException == nil {
		return e.message
	} else {
		return fmt.Sprintf("%s Nested: %s", e.message, e.innerException.Message())
	}
}

func (e *Exception) StackTrace() []string {
	return e.stackTrace
}

func (e *Exception) StackString() string {
	return formatStackTrace(e.stackTrace)
}

func (e *Exception) InnerException() *Exception {
	return e.innerException
}

func (e *Exception) Error() string {
	message := fmt.Sprintf("Exception: %s", e.message)
	message = message + fmt.Sprintf("\n%11s", "At: ")
	message = message + formatStackTrace(prefixLines(spaces(11), e.StackTrace()))

	if e.innerException != nil {
		innerErrorMessage := e.innerException.Error()
		message = message + fmt.Sprintf("\nNested %s", innerErrorMessage)
	}
	return message
}

func New(messageComponents ...interface{}) error {
	message := fmt.Sprint(messageComponents...)
	if len(message) == 0 {
		message = "An Exception Occurred"
	}
	return &Exception{message: message, stackTrace: callerInfo()}
}

func Newf(format string, args ...interface{}) error {
	message := fmt.Sprintf(format, args...)
	if len(message) == 0 {
		message = "An Exception Occurred"
	}
	return &Exception{message: message, stackTrace: callerInfo()}
}

func Wrap(err error) error {
	if err == nil {
		return nil
	}

	if typedEx, isException := err.(*Exception); isException {
		return typedEx
	} else if e, isError := err.(error); isError {
		return WrapError(e)
	} else {
		return New("Tried to wrap something that wasn't an error or an Exception")
	}
}

func WrapMany(err ...error) error {
	var ex *Exception
	for _, e := range err {
		if typeWrapped, didTypeCorrectly := Wrap(e).(*Exception); didTypeCorrectly {
			if typeWrapped != nil {
				if ex == nil {
					ex = typeWrapped
				} else {
					typeWrapped.innerException = ex
					ex = typeWrapped
				}
			}
		}
	}
	return ex
}

func WrapError(err error) error {
	if err == nil {
		return nil
	}
	return New(err.Error())
}

func GetStackTrace() string {
	return formatStackTrace(callerInfo())
}

func IsException(err error) bool {
	if _, typedOk := err.(*Exception); typedOk {
		return true
	} else {
		return false
	}
}

func AsException(err error) *Exception {
	if typed, typedOk := err.(*Exception); typedOk {
		return typed
	} else {
		return nil
	}
}

func prefixLines(prefix string, lines []string) []string {
	outputLines := []string{}
	for i, line := range lines {
		if i == 0 {
			outputLines = append(outputLines, line)
		} else {
			outputLines = append(outputLines, fmt.Sprintf("%s%s", prefix, line))

		}
	}
	return outputLines
}

func spaces(num int) string {
	return repeatString(" ", num)
}

func repeatString(token string, num int) string {
	str := ""
	for i := 0; i < num; i++ {
		str = str + token
	}
	return str
}

func formatStackTrace(stack []string) string {
	return strings.Join(stack, "\n")
}

func callerInfo() []string {
	callers := []string{}

	for i := 0; ; i++ {
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			return callers
		}

		if file == "<autogenerated>" {
			break
		}

		parts := strings.Split(file, "/")
		dir := parts[len(parts)-2]
		file = parts[len(parts)-1]

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		fullyQualifiedName := f.Name()
		segments := strings.Split(fullyQualifiedName, ".")
		functionName := segments[len(segments)-1]

		if dir != "go-exception" {
			caller := fmt.Sprintf("%s:%d %s()", file, line, functionName)
			callers = append(callers, caller)
		}
	}

	return callers
}
